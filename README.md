The following is a collection of algorithms with speed and memory info so I can look to make choices when writing a program.

# Algorithms in Python

In mathematics and computer science, an algorithm is a finite sequence of well-defined, computer-implementable instructions, typically to solve a class of specific problems or to perform a computation.

## Arrays

* One Dimentional Array
* Two Dimentional Array
* Lower Triangular Matrix
* Tridiagonal Matrix
* Tridiagonal Matrix


Stacks
 * push(value) -> None — adds the value to the stack
 * pop() -> Any — removes the most recent value from the stack
 * is_empty() -> bool — checks to see if there are items in the stack
	
Queues
 * enqueue(value) -> None — adds a new item to the rear of the queue
 * dequeue() -> Any — removes the first item in the queue
 * is_empty() -> bool— checks to see if there are items in the queue
 * peek() -> Any — returns the first item in the queue but doesn’t remove it
 
Deques
 * add_front(value: Any) -> None — adds a new item to the front of a deque
 * add_rear(value: Any) -> None — adds a new item to the end of a deque
 * remove_front() -> Any — returns the first item from the deque and removes it
 * remove_rear() -> Any — returns the last item from the deque and removes it
 * is_empty() -> bool — checks to see if there are items in the queue

## Stacks

    push(value) -> None — adds the value to the stack
    pop() -> Any — removes the most recent value from the stack
    is_empty() -> bool — checks to see if there are items in the stack

* Push()
* Pop()
* Display()
* Push, Pop, Display()

## Queues

    add_front(value: Any) -> None — adds a new item to the front of a deque
    add_rear(value: Any) -> None — adds a new item to the end of a deque
    remove_front() -> Any — returns the first item from the deque and removes it
    remove_rear() -> Any — returns the last item from the deque and removes it
    is_empty() -> bool — checks to see if there are items in the queue
    

## Recursion

Recursion is the process of defining a problem (or the solution to a problem) in terms of (a simpler version of) itself. For example, we can define the operation "find your way home" as: If you are at home, stop moving.

* Fibonacci Series


## Linked List

* Singly Linked Lists
* Doubly Linked List
* Singly Linked List Cycle
* Linked List Reversal 
* Linked List Nth to Last Node

## Tree

* Tree Representation
* Tree Traversals
* Binary Search Trees
* Binary Trees
* Tree Level Order

## Heaps

## Graphs

* Word Ladder
* Breadth First Search
* Knight's Tour
* Depth First Search

## Hashing

A hash function is any function that can be used to map data of arbitrary size to fixed-size values. The values returned by a hash function are called hash values, hash codes, digests, or simply hashes. The values are usually used to index a fixed-size table called a hash table.

## Asymptotic Notion

Asymptotic Notation is used to describe the running time of an algorithm - how much time an algorithm takes with a given input, n. There are three different notations: big O, big Theta (Θ), and big Omega (Ω).

* big O
* big Theta (Θ)
* big Omega (Ω)

## Time Complexity

In computer science, the time complexity is the computational complexity that describes the amount of computer time it takes to run an algorithm.

## Master Theorem

In the analysis of algorithms, the master theorem for divide-and-conquer recurrences provides an asymptotic analysis for recurrence relations of types that occur in the analysis of many divide and conquer algorithms.



## Spanning Trees

* Krushkal's Algorithm - Minimum Spanning Trees
* Prim's Algorithm - Minimum Spanning Tree
* Minimum Spanning Trees


## Sorting Algorithms

Bubble Sort(size=10000):  0.00295114517
Insertion Sort(size=10000):  0.01595640182
Selection Sort(size=10000):  8.99420881271
Heap Sort(size=10000):  0.13767814636
Quick Sort(size=10000):  0.0329117775
Merge Sort(size=10000):  0.06178402901


* Bubble Sort
* Insertion Sort
* Selection Sort
* Quick Sort 
* Heap Sort
* Merge Sort
* Shell Sort

## Searching Algorithms

In computer science, a search algorithm is an algorithm which solves a search problem. Search algorithms work to retrieve information stored within some data structure, or calculated in the search space of a problem domain, either with discrete or continuous values.

* Beam Search 
* Binary Search Iterative
* Binary Search Recursive
* A* Search
* Linear Search
* Jump Search
* Interpolation Search
* Exponential Search

## Greedy Method

* Job Sequencing Problem
* Fractional Knapsack Problem 
* Optimal Merge Pattern 
* Min # Coins Required

## Dynamic Programming

* Travelling Salesperson Problem
* Longest Common Subsequence
* Multistage Graph

## Backtracking

## Divide and Conquer

## Randomized

## Branch and Bound



